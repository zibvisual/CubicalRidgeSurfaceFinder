#pragma once

#include <cstdint>
#include <vector>
#include <unordered_map>
#include <queue>
#include <optional>

#include <utils/Vec.hpp>
#include <utils/Dims.hpp>
#include <field/RawField.hpp>

#include "Graph.hpp"
#include <fastmarching/FastMarching.hpp>
#include <utils/Mapping.hpp>
// #include "MarchingCubes.hpp"
#include <surface/Surface.hpp>
#include <surface/StaticSurface.hpp>
#include <surface/SurfaceUpdate.hpp>
#include <utils/Lattice.hpp>
#include <utils/ProgressbarReportHelper.hpp>

#include "Seed.h"
#include "Faces.hpp"
#include "FacesToCubicalMesh.hpp"
#include <utils/Range.hpp>


namespace futil
{
    class Face;
}

class HxSpatialGraph;

namespace ridgesurface
{
    /**
     * @brief
     *
     * TODO: m_graph is only necessary for the finalization step. Such, use it only there, patches shouldn't have an orienation.
     *
     */
    class CubicalRidgeSurfaceFinder
    {
    public:
        CubicalRidgeSurfaceFinder(progressbar::Progressbar& progress);
        ~CubicalRidgeSurfaceFinder(void);

        void setInput(const RawFieldView<float>* probability);
        void setThresholds(float min, float max);
        float getMin();
        float getMax();
        float getUndefinedValue();

        // void saveSeedpoints(FILE* fp);
        const CubicalRidgeSurfaceFinder& as_const() const;

        // from voxels // THIS IS MORE A HACK! INSTEAD THE SURFACE OBJECT SHOULD HAVE ALL THE DATA
        const Seed* getSeedFromVoxel(std::size_t id) const;
        std::optional<std::size_t> getSeedIndexFromVoxel(std::size_t id) const;
        float getDistance(VecFloat point);

        // Get seeds. Use const function if possible.
        const Seed& getSeed(std::size_t i) const;
        Seed& getSeed(std::size_t i);

        // Seed changes
        std::size_t numOfSeeds() const;
        uint64_t addSeed(Seed seed);
        // add a seedpoint automatically, if possible (if no seedpoint was set, returns None)
        std::optional<uint64_t> addSeed(float minDistanceRel, float maxDistanceNewSeed);
        void updateSeed(uint64_t id, Seed seed);
        bool removeSeed(uint64_t id);
        void clearSeeds();
        // Used in load operations, such that we can use a diff algorithm. 
        // Currently naive implementation and such takes O(nÂ²) time.
        std::vector<uint64_t> newSeeds(std::vector<Seed>& seeds);

        int removeSeedpointCandidates();
        int removeSeedpointCandidates(float minDistance);
        int removeSeedpointCandidatesWhenFullyCovered(std::size_t index);

        /**
         * @brief Calculates the new patches.
         */
        surface::SurfaceUpdate calculate();
        /**
         * @brief Calculate anew from all seeds.
         */
        surface::SurfaceUpdate recalculate();
        /**
         * @brief Calculate the surface generated by merching the patches together.
         *
         */
        void finalize(surface::StaticSurface* surface);//, HxSpatialGraph* graph);

        // Debug
        // void castToTwoLabels(unsigned char* labels);
        // void castCurrentSeedLabels(unsigned char* labels);
        void castToLabels(uint16_t* labels);
        // void castToSeedLabels(unsigned short* labels);
        // void castToSpatialGraph(HxSpatialGraph* graph);
        void castToTime(float* time) const;
        void castToDistance(float* distance) const;

        // void computeColoringOfSphere(std::size_t i, std::unordered_map<futil::Face, std::size_t>& map);
        // void computeIntegralCurves(std::size_t i, std::unordered_set<int64_t>& first, std::unordered_set<int64_t>& second);
        // void computeStartingGridpoints(std::size_t i, int64_t& first, int64_t& second);

        // std::vector<futil::Face> copyFacePatch();

        // float distanceOnSphere(futil::Face face);

    protected:
        void resetFields();
        /**
         * @brief calculated temporary patch of surface for given seed.
         *
         */
        void grow(std::size_t i);
        /**
         * @brief merges two fields together.
         *
         */
        void merge(std::size_t i);

        void merge_cum_fields(std::size_t i);
        void initialize_possible_neighbors(std::unordered_map<std::size_t, int>& neighbors);
        void track_neighbor_correspondence_by_volume(std::unordered_map<std::size_t, int>& neighbors);
        void update_neighbor_graph(std::size_t i, const std::unordered_map<std::size_t, int>& neighbors);
        void update_neighbor_graph_better(std::size_t i);

        void remove_non_touching_neighors();
        // not used right now, but could give better results
        void remove_non_touching_neighors_cube();
        void update_patch_orientations();

        void finalize_neighborhood_graph();

        // calculations done by calculate
        void updateInsert(uint64_t id);
        /**
         * @brief After clearing all necessary patches, one must call removeObsoleteTriangles on the surface. (To also clear triangles)
         *
         * @param i
         */
        void updateClear(uint64_t id);

        void addPatch(uint64_t id);

        /**
         * @brief Given voxel ids, tells you if there exists a face inbetween
         *
         * @param i
         * @param j
         * @return true
         * @return false
         */
        bool faceBetweenVoxels(std::size_t i, std::size_t j) const;

        // progressbar
        progressbar::Progressbar& m_progressbar;

        // Seeds
        std::unordered_map<uint64_t, Seed> m_seeds;
        uint64_t m_id_counter = 0;
        // Edits of Seeds
        std::unordered_set<uint64_t> m_seeds_update;
        std::unordered_set<uint64_t> m_seeds_in_surface;

        // List of voxels changed by a seed
        std::unordered_map<uint64_t, std::vector<int64_t>> m_seeds_voxels;
        // Neighborhood graph of seeds (seeds are only neighbors, if both their colors exist in the overlap)
        klenert::SparseGraph<bool> m_graph;

        // temporary memory used in grow()
        mutil::HashMapMappingView<SmallHashMap<int64_t, unsigned char>> m_label_view;
        std::unordered_set<int64_t> m_patch;
        int64_t m_first_grid_point;
        int64_t m_second_grid_point;

        // optional memory where data is saved (TODO: refactor, such that we have temporary memory itself as objects which then can get copied if necessary -> problematic as we use closures right now)
        std::unordered_map<Face, std::size_t>* ts_sphere_coloring;
        std::unordered_map<Face, float>* ts_sphere_distance;
        std::unordered_set<int64_t>* ts_integralcurve1;
        std::unordered_set<int64_t>* ts_integralcurve2;

        // Fast Marching object
        using MappingView = mutil::HashMapMappingView<SmallHashMap<int64_t, float>>;
        fastmarching::FastMarching<fastmarching::ObserverDistance<MappingView>> m_fm;

        // Inner labeling which can be transformed to create an unsigned char labeling for generate surface
        RawField<std::size_t> m_cum_label;

        // Input and Outputs
        const RawFieldView<float>* m_probability;
        RawField<float> m_cum_time;
        RawField<float> m_cum_distance;

        // save all updates to return later on
        surface::SurfaceUpdateBuilder m_surface_update;
        std::unordered_map<uint64_t, bool> m_patch_orientation;

        FacesToCubicalMesh m_surface_writer;
        // candindates for seeding points (automatic) (patch_id -> candidates)
        std::unordered_map<uint64_t, std::vector<int64_t>> m_seedpoints_candidates;

        // cached lattice
        Lattice m_lattice;

        // void initMemory();
        // void freeMemory();
    };

} // namespace ridgesurface